# 杂记🤓🤓🤓
* (`递归`):不是说递归就要return，仅仅遍历一遍树状结构不用return东西
* (递归):return的东西原路返回了。
* (CommonJS):暴露是module.exports 注意有个"s"
* (CommonJS):CommonJS的导入方式是同步的
* (browserify):用来将commonjs方式require的包导入至代码上端
* (babel):用来将ES6代码转为ES5代码
* (node_modules):可执行文件在/node_modules/.bin目录下
* (CommonJS):CommonJS借助browserify工具实现require（browserify index.js -o bundle.js）
* (ES6 Module):es6-module借助babel进行es6->es5(babel ./src --out-dir ./lib),然后借助browserify实现require(browserify index.js -o bundle.js)
* (工作)困了的话就戴耳机听歌
* (git)终端查看git提交记录 git log --graph
* (gitk)一个git提交记录查看命令工具
* (代码健壮)对数组的判断:Array.isArray(data) && data.length || []
* (shell)接受参数：$0,$1
* (Generator生成器):*号声明的函数第一次执行产生生成器，后续通过next()进行逐步调用
* (call和apply):注意call和apply的调用者是被修改this指向的对象，call和apply的第一个参数是新的this，第二个开始参数是新this需要的参数
* (Generator生成器):next()方法中参数可以设置上一个yield的返回值
* (深拷贝浅拷贝):解构赋值是深拷贝，不要被结构赋值对象里面的基本数据类型和引用输入类型搞混
* (sass):注意sass待转换文件必须是xxx.sass文件(捂脸.gif)
* (sass):sass的几个关键点:嵌套、变量、混合器、继承、导入
* (sass):  :global用来覆盖UI库样式
* (闭包):闭包一定要有return吗？
* (call和apply)：注意call和apply修改了某函数的this执行并且立即执行，bind需要手动再执行
* (框架):框架中data的更新与UI层的渲染，注意复杂数据类型更新UI层无感的情况，注意key的使用
* (Object.prototype.toString):判断类型，Object.prototype.toString()永远的神。let ts = Object.prototype.toString() ts.call(待判断对象)
* (无穷大与无穷小):Infinity和-Infinity
* (引用数据类型)：注意引用数据类型之间的赋值问题。（写leetcode的回文字符串时候数组的赋值。应该用深拷贝而不是直接赋值）
* (异步):异步处理的发展:回调函数 --> promise --> Generator --> async await --> RXJS
* (函数):函数语句和函数表达式。函数语句存在提升的情况。
* (迭代)：基于函数的迭代比基于循环的迭代要慢一些。
* (dom):createDocumentFragment()作为子dom添加进父dom时，只会将documentFragment其所有的子孙节点添加给父dom，不包括docuemntFragment其自身。
* (虚拟DOM算法)：并不是虚拟DOM就比真实DOM操作要快,而是用虚拟DOM算法去操作真实DOM，比直接操作真实DOM性能更高。
* (虚拟DOM算法):虚拟DOM算法 = 虚拟DOM + DIFF算法
* (Math.random()):获取min和max之间的随机数：(Math.random() * (max - min)) + min
* (Math.random()):获取min和max之间的整数(包括max和min)：Math.floor((Math.random() * (max - min + 1))) + min
* (箭头函数):箭头函数后的函数体不带花括号即默认return
* (CSS选择器):选择除第一个元素后的其他元素:p:not(:nth-child(1)){color:pink}
* (some 和 every)：some中当return了一个true,就不再循环。every中return了一个false,就不再循环。
* (React 源码):render方法实际上是调用了React.createElement方法(ReactElement方法)
* (避免操作state):避免操作结构赋值取得的state的方法目前是：{...state.xxx,newKey:newValue},用扩展运算符扩出新的对象。或者JSON.paurse(JSON.stringify(state.xxx))深拷贝
* (浅拷贝的坑)：不要忘记浅拷贝的坑，类似moment对象的使用
* (some和every)：之前记住的some返回一个true就停止循环，every返回一个false就停止循环，注重的是循环的过程。some只要数组中某一元素满足条件即返回true,every需要数组中所有元素满足条件才返回ture,强调的是返回值。
* (好看的webstorm字体)：Raleway                                        │~                                                                     
* （元素的宽高）:元素的宽等于 width + border*2 + padding*2             │~                                                                     
* (content-box)：width就是width,border就是border,padding就是padding    │~                                                                     
* (border-box)：width+2*border+2*padding == 设置的width，width会被borde│~                                                                     
r和padding挤压。
* (事件委托):事件委托就是将元素的事件委托给他的父级元素或更外级的元素处理，实现机制就是事件冒泡。
* (addEveneListener):addEventListener有三个参数(event,function.useCapture),第三个参数决定事件处理函数在哪个阶段被调用(冒泡阶段 和 捕获阶段)
* (阻止事件冒泡): 子元素设置：event.stopPropagation() 或者直接 return false
* (事件委托):为父元素绑定某事件之后，通过event.target.nodeName.toLowerCase()==="li" 的方法判断被点击元素的tagName
* (系统盘制作软件):balenaEtcher和rufus
* （虚拟机软件）:qemu
* (较有用的apt命令):apt -f install ; apt --fix-broken install ; apt autoremove
* (高阶函数):高阶函数的说法来自于函数式编程，函数作为参数进行传递，类似map、reduce、filter这都是高阶函数，因为他们传递就是函数参数。
* (函数式编程)：函数式编程把一切变成关注点为 输入 和 输出
* (学习渠道): youtube视频、掘金、leetcode
* (git):git几个方面 ：完美的commit、分支策略、pull request、
* (vim快捷键)：格式化代码: gg = G
* (字符串方法): split() 通过括号内符号对字符串进行数组化分割，若传递""则挨个数组化
* (变量初始化):变量使用时是什么类型，初始化时就采取什么类型。
* (说给自己听的):敲代码就像是在用铁镐敲击大岩石块，凿一下凿一下的破开它。
* (快速生成数组):new Array(个数).fill("")
* (WSL2):这是个酷毙了的东西。😀😀😍😍
  * (递归):
      ``` javascript
               // 递归为树状数组添加层级标识
          let arr = [
          {
              title:"test"
          },
          {
              title:"test",
              children:[
                  {title:"test2"},
                  {title:"test2"},
              ]
          },
          {
              title:"test",
              children:[
                  {
                      title:"test2",
                  },
                  {
                      title:"test2",
                      children:[
                          {title:"test3"},
                          {title:"test3"},
                      ]
                  },
              ]
          },
      ]
      function setLevel(arr){
    
          // 私有函数
          function setLevelFun(arr,level){
              level++;
              arr.map(item => {
                  item.level = level;
                  if(item.children){
                      setLevelFun(item.children,level);
                  }
              })
          }
    
          setLevelFun(arr,0)
      }
      setLevel(arr);
      ```
* (linux):大胆的去看软件里面的配置文件。
* (Linux PATH)：~/.profile文件 和 /usr/local/bin目录(软链接) 
* (work):要持续的联系测试人员，不能停滞。
* (中序遍历):中序遍历是从小到大依次遍历。
	```javascript
		function middleConsole(callback){
			// ---- 私有函数 -----
			function middleConsoleFun(node,callback){
				if(node !== null){
					middleConsoleFun(node.left,callback);
					callback(node);
					middleConsoleFun(node.right,callback);
				}	
			}

			middleConsoleFun(root,callback());
		}
	```
* (先序遍历):先序遍历是中间节点优先于子孙节点被遍历
* (后序遍历)：后序遍历是中间节点落后于子孙节点被遍历
* (二叉树遍历):都是围绕着中间节点来的。
	* 中序遍历：在三个节点中，只要是中间节点，就是第二个被遍历的（node.left最先被遍历）
	* 先序遍历；在三个节点中，只要是中间节点，就是最先被遍历的
	* 后续遍历：在三个节点中，只要是中间节点，就是最后被遍历的。

* (左右查询):<你不知道的js>第一章中的LHS和RHS
	* LHS:操作的赋值目标是谁
	* RHS:谁是赋值操作的源头
* (右查询的意义)：如果RHS查询在所有的嵌套作用域中寻找不到所需要的变量，引擎就会抛出ReferenceError异常。
* (异常):ReferenceError该异常同作用域判别失败相关。
* (右查询和referenceError异常):
	```javascript
		console.log(a);
		当RHS查询失败的时候，抛出ReferenceError.
		因为无法找到 操作赋值的源头。

		问题：为什么 a = 1 ,不会抛出ReferenceError
			因为 a = 1,执行的是LHS左查询。如果找不到 被赋值操作的目标，那么就声明该变量继续赋值操作。
	```
* (var and let) : 可以这样理解，var 的最小作用域单位是函数作用域，let 的最小作用域单位是{}
* (匿名函数和立即执行函数):注意匿名函数是匿名函数，立即执行函数是立即执行函数。
* (全局变量):for循环的循环条件中使用var定义的i变量，是全局变量或者函数变量。
* （let）：和上面相对于，for循环中使用let定义的i变量，只作用于该循环体作用域。
* （提升）：声明会被提升，赋值留在原地。函数声明会被提升，函数表达式不会被提升。
* (异常):TypeError:xxx is not a function 例子：undefined();  let a = 123;a.map(() => console.log("asdf"));
* (提升与停留):
	```javascript
	// 总是记得变量的声明提升，但是却忽略赋值操作的原地停留。
	test(); // TypeError  (is not a function)
	myFun(); // ReferenceError (is not defined)
	var test = function myFun(){
		console.log(":)");
	}
	```
* (var): 重复的无赋值的声明会被省略。
	```javascript
		var test = ":)";
		var test;
		console.log(test); // ":)"
	```
* (提升):函数声明的提升的最小作用域单位是 块级作用域 {}
	```jvascript
		fun(); // TypeError 
		function fun(){
			console.log(":)");
		}
	```
* (闭包)：闭包的作用之一：从外部访问函数内部的变量
	```javascript
		function outter(){
			let test = "被你发现啦！";
			function inner(){
				return test;
			}
			return inner;
		}
		const myFun = outter();
		console.log(myFun()); // "被你发现啦！"
	```
* (闭包)：闭包强调的是外部函数的函数作用域未被回收。外部函数的函数作用域仍被内部函数给引用。
* (闭包):闭包的作用之一： 闭包使得内部函数得以继续的使用其定义位置的词法作用域。
* (闭包):经典的for循环问题
	```javascript
		for(var i=0;i<3;i++){
			setTimeout(() => {console.log(i)},1000);
		}
		// ---- 代码的表面语义：每隔1s输出当前i的值；----
		// ---- 实际执行结果：在一秒后直接输出3个3；----
		// ---- 首先明确一点，for循环是同步代码，setTimeout是异步代码（event loop），----
		// ---- 异步代码肯定在同步代码执行完毕之后执行（重点1） -----
		// ---- 且var i 这样的写法使得在全局作用域中只有一个i（重点2） ----
		// ---- 所以最终一次性输出3个3；
		
		// ---- 使用闭包解决这个问题（实现单独作用域） ----
		    for(var i =0; i < 3;i++){
        		(function(){
            		  var j = i; // ---- 这个var的作用域为当前匿名函数作用域 ----
            		  setTimeout(() => {
                	  console.log(j);
            		},1000);
        	    })()
		// ---- 简化版本 ----
		    for(var i =0; i < 3;i++){
        		(function(j){
            		  setTimeout(() => {
                	  console.log(j);
            		  },1000);
        		})(i)
    		    }
		// ---- 总结：虽然说使用闭包，但我觉得更像是利用了var的最小活动作用域是函数作用域这一特性 ----
		// ---- 同理，那么我们可以利用let最小活动作用域是块作用域这一特性，直接劫持每一次循环产生的块作用域。
		    for(let i =0; i < 3;i++){
        		setTimeout(() => console.log(i),1000);
    		    }
    }
	```
* (while循环):break语句和return可以跳出while循环。
* (翻墙):shadowsocks-libev永远的神。用apt下载,支持新方法
* (工作)：项目上线到正式一定要去看
* (linux):linux开启某个端口的命令 sudo ufw allow 8888 或者 sudo ufw allow from 192.168.1.0/24 to any port 8888
* (React风格)：关于 子组件的state问题 子组件的state越多，组件耦合度越低，反之亦然。
* (深拷贝):JSON.parse(JSON.stringify())有个很大的缺点：深拷贝对象的时候会过滤掉内容为函数的对象属性。
* (前端与id)：1.使用Date: Date.now() / new Date(); 2.配合使用Math.round()和Math.random()
